#!/usr/bin/env python

def update_costmap():


    # NOTE: not the function of costmap is 1-D (line), should be modified into 2-D (circle)
    # range covered by sizeof obs + car (so the car become a point)	
    cost_range_cor = np.around( car_dim + obs_dim, int(abs(np.log10(map_res))))   
    # from map cor to cost cor (index)
    cost_range_index = int(np.ceil(cost_range_cor / map_res))

    #  update castmap in all t within t_ahead 
    t_ahead = get_t_ahead()
    # pass t_ahead to prevent different costmap size[0] (t_ahead)
    if reset_costmap(t_ahead):
	pass
 
#    else:    
#	rospy.loginfo("No prediction is needed, turn to local costmap now!")

    if t_ahead > 0:
	t_ahead = t_ahead + 1  # for the next for loop
    else:
	t_ahead = 1  
    
    # NOTE -1 is a quick fix...	
    for t in range(t_ahead):
	# NOTE: this is linear motion prediction
        pose = obs_pose + obs_vel * t * t_res
     	#  for each obstacle
        for i in range(len(obs_pose)):
	    # check if the prediction pose of obstacle is out of range
	    # NOTE: the -1 here is used to prevent out of borders
	    if np.all(abs(pose[i]) < (map_size / 2 - obs_dim - car_dim - 1)): 
	        # from map cor to cost cor
		# NOTE OMG!! have to add them after transformed
	        upper = pose_to_costcor(pose[i]) + cost_range_index  # bot-right 
	        lower = pose_to_costcor(pose[i]) - cost_range_index  # top-left

	        row_idx = np.arange(lower[1], upper[1]+1)  # index: y_min to y_max
	        col_idx = np.arange(lower[0], upper[0]+1)  # index: x_min to x_max

		    # location that obstacle at has probability of collision equals to 1
  	        # NOTE NOTE NOTE 
#		change_costmap_val( t, row_idx-55, col_idx-55, 1)
		change_costmap_val( t, row_idx, col_idx, 1)
		    

		# NOTE: only x-direction vel is considered ([i][0])
		if obs_vel[i][0] > 0:
		    # cost function: in front of the obstacle
		    # NOTE:5 meters ahead, this should cover the costfunction val that > 0
		    for j in range(upper[0] + 1, upper[0] + 50):
		        dist_to_obs = (j-upper[0]) * map_res
			cost_val = cost_function(dist_to_obs, obs_vel[i][0])

			# check if the index is out of range
			if bordercheck(j):
			    # change the costval col-wise
#			    change_costmap_val( t, row_idx-55, [j-55], cost_val)
			    change_costmap_val( t, row_idx, [j], cost_val)
#			    if t==0 and i == 1:
#     		      	    	rospy.loginfo("obs_1  row_idx and [j ]:{0},{1}, pose[1]: {2}, and pose transfered: {3} and shape of costmap: {4}".format(row_idx,j, pose[i], pose_to_costcor(pose[i]), costmap.shape))
#			    rospy.loginfo("mom, i'm here!!!! obs_pose : {0}".format(obs_pose))
#			    rospy.loginfo("upper[0] and j : {0} {1}".format(upper[0],j))
			else :
			    pass

		    # cost function: rear of the obstacle
		    for k in range(lower[0] - 50, lower[0] - 1):
		        dist_to_obs = - (lower[0]-k) * map_res
			cost_val = cost_function(dist_to_obs, obs_vel[i][0])
			# check if the index is out of range
			if bordercheck(k):
			    # change the costval col-wise
#			    change_costmap_val( t, row_idx-55, [k-55], cost_val)
			    change_costmap_val( t, row_idx, [k], cost_val)
#			    rospy.loginfo("dad, i'm here!!!!!!!!")
			else:
			    pass

		elif obs_vel[i][0] < 0:
		    for l in range(lower[0] - 50, lower[0] - 1):
		        dist_to_obs = (lower[0]-l) * map_res
			cost_val = cost_function(dist_to_obs, obs_vel[i][0])

			# check if the index is out of range
			if bordercheck(l):
			    # change the costval col-wise
#			    change_costmap_val( t, row_idx-55, [l-55], cost_val)
			    change_costmap_val( t, row_idx, [l], cost_val)
#			    rospy.loginfo("mom, i'm here!!!! obs_pose : {0}".format(obs_pose))
			else :
			    pass

		    # cost function: rear of the obstacle
		    for m in range(upper[0] + 1, upper[0] + 50):
		        dist_to_obs = -(m-upper[0]) * map_res
			cost_val = cost_function(dist_to_obs, obs_vel[i][0])
			# check if the index is out of range
			if bordercheck(m):
			    # change the costval col-wise
#			    change_costmap_val( t, row_idx-55, [m-55], cost_val)
			    change_costmap_val( t, row_idx, [m], cost_val)
#			    rospy.loginfo("dad, i'm here!!!!!!!!")
			else:
			    pass

	    else:
		pass
